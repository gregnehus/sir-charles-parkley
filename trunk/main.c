#pragma config(Sensor, S4,     LightSensor,         sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//********************************************************
//********************************************************
//*!!Sensor, S1, SonarSensor, !!*//
//*!!Sensor, S4, LightSensor, sensorLightActive, , !!*//
//*!!Motor, motorA, motorA, tmotorNxtEncoderClosedLoop, !!*//
//*!!Motor, motorB, motorB, tmotorNxtEncoderClosedLoop, !!*//
//*!! !!*//
//*!!Start automatically generated configuration code. !!*//
const tSensors SonarSensor = (tSensors) S1; //*!!!!*//
//const tSensors LightSensor = (tSensors) S4; //sensorLightActive //*!!!!*//
const tMotor motorA = (tMotor) motorA; //tmotorNxtEncoderClosedLoop //*!!!!*//
const tMotor motorB = (tMotor) motorB; //tmotorNxtEncoderClosedLoop //*!!!!*//
//*!!CLICK to edit 'wizard' created sensor & motor configuration. !!*//

/**********************************************************************************
* File:         main.c
* Authors:      Greg Nehus, Matt Odille
* Description:  This program is written in ROBOTC for the Lego Mindstorms NXT
*               platform.  It's a $$$$$$$ make bank
*
* motorA: Drive
* motorB: Steer
* S1: Sonar
* S4: Light
*
*********************************************************************************/

/**********************************************************************************
* Preprocessor Definitions
*********************************************************************************/
#define TARGET_LIGHT_VALUE 30
#define MOTOR_A_SPEED -15
#define MOTOR_B_SPEED 75

#define track 4.625
#define wheelbase 7.25
#define steeringangle 40
#define WHEEL_DIAMETER 5.5
#define turning_radius 14.56

/**********************************************************************************
* Function prototypes
*********************************************************************************/
void set_steering_angle(int angle);
void halt();
void park(float deltaX, float deltaY);
float getTurningRadius();
float inches_to_centimeters(float inches);
void drive(float distance);
float get_angle_between_circles(float deltaX, float deltaY);
float get_distance(float deltaX, float deltaY);
float get_needed_park_y_coordinate(float deltaX);
/**********************************************************************************
* Global variables for steering motor
*********************************************************************************/
int steeringAngle = 0; //this assumes initial steering angle is straight

/**********************************************************************************
* Global variables for PID controller
*********************************************************************************/
float dState[2];  //Last position input
float iState[2];  //Integrator state
float iMax[2];    //Maximum allowable integrator state
float iMin[2];    //Minimum allowable integrator state
float pGain[2];   //Proportional gain
float iGain[2];   //Integral gain
float dGain[2];   //Derivative gain

/**********************************************************************************
* LightSensor
*********************************************************************************/
int nLight;
float fError = 0.0;
float fsError = 0.0;

/**********************************************************************************
* Task (thread) for reading from the LightSensor
*********************************************************************************/
task tLightSensor()
{
	nSchedulePriority = kDefaultTaskPriority;
	SensorMode[LightSensor] = modePercentage;
	while(true)
	{
	  // delay 3 milliseconds since that's the fastest the sensor can read
		wait1Msec(3);

		// take a reading and calculate the error
		nLight = SensorValue(LightSensor);
		nxtDisplayCenteredBigTextLine(2, "S4=%d", nLight);
		fError = (TARGET_LIGHT_VALUE - nLight);
		if (fError > fsError) fsError = fError;
	}
	return;
}


/**********************************************************************************
* PID controller
*********************************************************************************/
float UpdatePID(int x, float error, float position)
{
	float pTerm = 0.0, dTerm = 0.0, iTerm = 0.0, result = 0.0;
	pTerm = pGain[x] * error;
	// calculate the proportional term
	// calculate the integral state with appropriate limiting
	iState[x] += error;
	if (iState[x] > iMax[x])
	  iState[x] = iMax[x];
	else
	  if (iState[x] < iMin[x])
	    iState[x] = iMin[x];
	iTerm = iGain[x] * iState[x]; // calculate the integral term
	dTerm = dGain[x] * (position - dState[x]);
	dState[x] = position;
	result = pTerm + iTerm - dTerm;
	return (result);
}

/**********************************************************************************
* Arbiter nAngle is the PID command
*********************************************************************************/
void Arbiter(int nAngle)
{
	int outputAngle = 0;

	// Initialize the motors
	bFloatDuringInactiveMotorPWM = false;
	//nMaxRegulatedSpeedNxt = 2160;
	//nPidUpdateInterval = 1;
	//nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	//nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	motor[motorA] = MOTOR_A_SPEED;
	set_steering_angle(nAngle);

	// PID save area.
	dState[0] = 0.0;
	iState[0] = 0.0;

	// Tune the PID using gains parameters
	pGain[0] = 2.95;
	iGain[0] = 0.0;
	dGain[0] = 0.026;

	// Percent of the input command (steering angle)
	iMin[0] = (nAngle / 100.0) * 25.0;
	iMax[0] = (nAngle / 100.0) * 75.0;

	while (true)
	{
		// call the PID controller
		if (fError != 0.0)
		{
			outputAngle = nAngle - (int) UpdatePID(0,abs(fError),abs(fError));
			if (outputAngle > nAngle) outputAngle = nAngle;
			if (outputAngle < 0) outputAngle = 0;
			if (outputAngle > 90) outputAngle = 90;
			set_steering_angle(outputAngle);
			wait1Msec(1.0);
		}
	}
	motor[motorA] = 0;
	motor[motorB] = 0;
	while(nMotorRunState[motorA] != runStateIdle);
	return;
}

void park(float deltaX, float deltaY){
   float currentTurningCircleOrigin_X,currentTurningCircleOrigin_Y;
   float parkedTurningCircleOrigin_X, parkedTurningCircleOrigin_Y;

   currentTurningCircleOrigin_X = turning_radius - track/2;
   currentTurningCircleOrigin_Y = 0;

   parkedTurningCircleOrigin_X = deltaX - getTurningRadius + track/2;
   currentTurningCircleOrigin_Y = deltaY;

   float circleDeltaX = parkedTurningCircleOrigin_X - currentTurningCircleOrigin_X;
   float nX = get_needed_park_y_coordinate(circleDeltaX);
   //double nCarx = nX
   nxtDisplayCenteredTextLine(4, "needed dX=%f", nX);
   //while(1);
   drive(inches_to_centimeters(nX - deltaY));
   set_steering_angle(45);
   set_steering_angle(0);

   //float turningRadius = getTurningRadius();
   //nxtDisplayCenteredTextLine(4, "radius=%d", turningRadius);
   while(1);

   drive(-turning_radius * get_angle_between_circles(circleDeltaX, deltaY));

   set_steering_angle(-45);
   drive(- turning_radius * (PI - get_angle_between_circles(circleDeltaX, deltaY)));
   //drive(- turning_radius * get_angle_between_circles(deltaX, deltaY));

}

float get_angle_between_circles(float deltaX, float deltaY){

  return 2.0 * atan((sqrt((deltaX * deltaX) + (deltaY * deltaY)) - deltaX)/ deltaY);
}
float getTurningRadius(){
  return track/2.0 + wheelbase / sinDegrees(steeringAngle);

}

void drive(float distance){

  nMotorEncoder[motorA] = 0;
  motor[motorA] = -1 * (abs(distance)/distance) * 40;

  while (abs(nMotorEncoder[motorA]) < (long)abs(distance / (PI * WHEEL_DIAMETER) * 360.00));
  motor[motorA] = 0;
  wait10Msec(10);


}
float get_distance(float deltaX, float deltaY){
    return sqrt( deltaX * deltaX + deltaY * deltaY);
}

float get_needed_park_y_coordinate(float deltaX){
  float distance = ((turning_radius) - track) * ((turning_radius ) - track);
   return sqrt( distance   - (deltaX * deltaX));
}

float inches_to_centimeters(float inches){
  return inches * 2.54;
}

/********************************************************************************
 * Function: void halt()
 * Parameters: None
 * Return: None
 * Description: This function stops the driving motor.
 */
void halt()
{
    motor[motorA] = 0;
    wait1Msec(100);
    return;
}

/********************************************************************************
 * Function: void set_steering_angle()
 * Parameters: the angle, between 0 (left-most) and 90 (right-most)
 * Return: None
 * Description: This function sets the angle of steering.
 */
void set_steering_angle(int angle)
{
  int direction = 1;

  //nxtDisplayCenteredBigTextLine(4, "angle=%d", angle);

  // base case
  if(angle == steeringAngle) return;

  // reverse direction if need be
  if(angle < steeringAngle) direction = -1;

	// reset motor encoder value and set motor speeds
	nMotorEncoder[motorB] = 0;
	motor[motorB] = MOTOR_B_SPEED * direction;

	// wait for desired motor encoder value
	while( abs(nMotorEncoder[motorB]) != abs(angle-steeringAngle) );

	// stop motor and return
	motor[motorB] = 0;
	steeringAngle = angle;
	return;
}

//* ********************************************************** *
//* * Main program
//* ********************************************************** *
task main()
{
	nSchedulePriority = kDefaultTaskPriority;
	eraseDisplay();

	// Start Light sensors
	//StartTask(tLightSensor);
	//wait1Msec(1000);

	// Call the Arbiter
	//Arbiter(45);

	park(8, 8);
	set_steering_angle(0);
	//StopAllTasks();
	//return;
}
