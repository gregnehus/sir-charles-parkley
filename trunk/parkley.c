#pragma config(Sensor, S1,     sonarSensor,         sensorSONAR)
#pragma config(Sensor, S3,     bumperSensor,        sensorTouch)
#pragma config(Sensor, S4,     lightSensor,         sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorNormal, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************************************************
* Tweakable macros
**********************************************************************************/
// light sensor
#define LIGHT_VALUE_CARPET 58
#define LIGHT_VALUE_TAPE 34

// drive motor
#define DRIVE_SPEED 100

// PID tuning
#define PID_dT 0.002
#define PID_Pc 0.5
#define PID_Kc 2.5

// PID
#define OFFSET_TWEAK 0
#define PID_Kp (0.6 * PID_Kc)
//#define PID_Ki 0.143
#define PID_Ki (2 * PID_Kp * PID_dT / PID_Pc)
//#define PID_Ki 0.0
#define PID_Kd (PID_Kp * PID_Pc / (8 * PID_dT))
//#define PID_Kd 5
//#define PID_Kd 0.0

#define PID_INTEGRAL_MAX 500
#define PID_INTEGRAL_MIN -500

//Car info
#define track 4.625
#define wheelbase 7.25
#define WHEEL_DIAMETER 5.5
#define turning_radius 6
//#define turning_radius 14.56

/**********************************************************************************
* Global variables
**********************************************************************************/
// PID
float Kp = PID_Kp;     //the Konstant for the proportional controller
float Tp = 80.0;     //the Target steering angle (straight)
float offset; //average of the tape and carpet readings
float Ki = PID_Ki;
float integral = 0.0;
float Kd = PID_Kd;

// Light sensor
float prevError = 0.0;
float error = 0.0;

// Sonar sensor
int SonarValue;

// Steer motor
int steeringAngle = 45;//(STEER_VALUE_LEFTMOST + STEER_VALUE_RIGHTMOST) / 2; //this requires initial steering angle to be straight ahead

// Park
bool isParking = false;


/**********************************************************************************
* Function prototypes
**********************************************************************************/
float GetPID(float fError);
void park(float deltaX, float deltaY);

float inches_to_centimeters(float inches);
void drive(float distance, int leftSpeed, int rightSpeed);
float get_angle_between_circles(float deltaX, float deltaY);
float get_needed_park_y_coordinate(float deltaX);
float distanceFromWall = 0;
//float get_distance(float deltaX, float deltaY);

/**********************************************************************************
* Light sensor thread
**********************************************************************************/
task tLightSensor()
{
	nSchedulePriority = kDefaultTaskPriority;
	SensorMode[lightSensor] = modePercentage;
	int LightValue;

	while(!isParking)
	{
	  // delay 3 milliseconds since that's about the fastest the light sensor can read
		wait1Msec(3);

		// take a sensor reading and calculate the error by subtracting the offset
		LightValue = SensorValue(lightSensor);
		error = LightValue - offset;
		nxtDisplayTextLine(1, "S4=%d", LightValue);
		nxtDisplayTextLine(3, "error=%f", error);

		//wait1Msec(3000);
	}
	return;
}

/**********************************************************************************
* Sonar sensor thread
**********************************************************************************/
task tSonarSensor()
{
	nSchedulePriority = kDefaultTaskPriority;


	while(!isParking)
	{


	  // delay 15 milliseconds since that's about the fastest the sonar sensor can read
		wait1Msec(15);

		// take a sensor reading
		SonarValue = SensorValue(sonarSensor);

		if (distanceFromWall == 0) distanceFromWall = SonarValue;
		nMotorEncoder[motorA] = 0;
		while (SensorValue(sonarSensor) >= distanceFromWall + track){
		  nxtDisplayCenteredBigTextLine(3, "boom=%d", abs(nMotorEncoder[motorA]));
		  //nxtDisplayCenteredBigTextLine(3, "boom=%d", abs(nMotorEncoder[motorA]));

		  if (abs(nMotorEncoder[motorA]) >= (long)(inches_to_centimeters(wheelbase)  / (PI * WHEEL_DIAMETER * 2/3 ) * 360.0 )   ){
		    //isParking = true;
		  };

		  //(long)abs(distance / (PI * WHEEL_DIAMETER) * 360.00)
		}
	}

	return;
}


/**********************************************************************************
* Main thread
**********************************************************************************/
task main()
{
  int controllerOutput;

	nSchedulePriority = kDefaultTaskPriority;

	// setup motors
	//bFloatDuringInactiveMotorPWM = false;
	//nMaxRegulatedSpeedNxt = 2160;
	//nPidUpdateInterval = 1;
	//nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	//nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;

	eraseDisplay();

	// initialize values of PID globals
	offset = ((LIGHT_VALUE_CARPET + LIGHT_VALUE_TAPE) / 2) + OFFSET_TWEAK;




  // start sonar sensor
	StartTask(tSonarSensor);
	wait1Msec(1000);

	// start light sensor
	StartTask(tLightSensor);
	wait1Msec(1000);

	// perform line-following
	motor[leftMotor] = 50;
	motor[rightMotor] = 50;
	while(!isParking)
	{
	  controllerOutput = GetPID(error);
	  nxtDisplayTextLine(5, "L=%f", Tp + controllerOutput);
	  nxtDisplayTextLine(7, "R=%f", Tp - controllerOutput);
	  motor[leftMotor] = (int) (Tp + controllerOutput);
	  motor[rightMotor] = (int) (Tp - controllerOutput);
	}

	// perform parallel parking
	park(distanceFromWall/2.54 + track, 2);

}











/**********************************************************************************
* Function: float GetPID()
* Parameters: takes the current error reading as its only argument
* Return: None
* Description: This method returns the PID output (a steering angle adjustment)
**********************************************************************************/
float GetPID(float fError)
{
  float pTerm = 0.0, dTerm = 0.0, iTerm = 0.0;

  // [p]roportional term calculations
  pTerm = Kp * fError;

  // [i]ntegral term calculations
  integral = integral + fError;
	if (integral > PID_INTEGRAL_MAX)
	  integral = PID_INTEGRAL_MAX;
	else
	  if (integral < PID_INTEGRAL_MIN)
	    integral = PID_INTEGRAL_MIN;
  iTerm = Ki * integral;

  // [d]erivative term calculations
  dTerm = Kd * (fError - prevError);
  prevError = fError;

	return (pTerm + iTerm + dTerm);
}


void SetSteeringAngle(int targetAngle)
{
  return;
}


/**********************************************************************************
* Function: void park()
* Parameters: float deltaX, float deltaY
* Return: None
* Description: This function performs parallel parking.
**********************************************************************************/
void park(float deltaX, float deltaY){
   float currentTurningCircleOrigin_X, currentTurningCircleOrigin_Y;
   float parkedTurningCircleOrigin_X, parkedTurningCircleOrigin_Y;

   deltaX = deltaX + track ;
   currentTurningCircleOrigin_X = turning_radius - track/2;
   currentTurningCircleOrigin_Y = 0;

   parkedTurningCircleOrigin_X = deltaX - turning_radius + track/2;
   parkedTurningCircleOrigin_Y = deltaY;

   float circleDeltaX = parkedTurningCircleOrigin_X - currentTurningCircleOrigin_X;
   float nX = get_needed_park_y_coordinate(circleDeltaX);
    drive(inches_to_centimeters(nX-deltaY) * 2,50,50);

   //drive(inches_to_centimeters(turning_radius * PI * 2), -60,-20);
   //drive(inches_to_centimeters(turning_radius * PI * 2));

   //while(1);
   float angleBetweenCircle = get_angle_between_circles(circleDeltaX,deltaY + nX);

   //nxtDisplayCenteredTextLine(4, "angle= %f", angleBetweenCircle);
   //drive(inches_to_centimeters(turning_radius * angleBetweenCircle));


   //drive( inches_to_centimeters( turning_radius * (angleBetweenCircle) )+  wheelbase);
   drive(inches_to_centimeters(turning_radius * angleBetweenCircle), -60,-20);

   drive(inches_to_centimeters(turning_radius * angleBetweenCircle ) - 4, -20,-60);


   //drive(- turning_radius * get_angle_between_circles(deltaX, deltaY));
  //StartTask(we_are_the_champions);
}

float get_angle_between_circles(float deltaX, float deltaY){
    return atan(deltaY/deltaX);
}


void drive(float distance, int leftSpeed, int rightSpeed)
{
  nMotorEncoder[motorA] = 0;
  nMotorEncoder[motorC] = 0;
  motor[motorA] =  leftSpeed;
  motor[motorC] = rightSpeed;

  while (1){
    if (leftSpeed > rightSpeed){
     if (abs(nMotorEncoder[motorA]) > (long)abs(distance / (PI * WHEEL_DIAMETER) * 360.00)) break;

   }else{
     if (abs(nMotorEncoder[motorC]) > (long)abs(distance / (PI * WHEEL_DIAMETER) * 360.00)) break;
   }
  }


  motor[motorA] = 0;
  motor[motorC] = 0;
}

float get_needed_park_y_coordinate(float deltaX)
{
  float distance = ((turning_radius * 2) - track) * ((turning_radius * 2) - track);
  return sqrt( distance   - (deltaX * deltaX));
}

float inches_to_centimeters(float inches){
  return inches * 2.54;
}

//float get_distance(float deltaX, float deltaY){
//    return sqrt( deltaX * deltaX + deltaY * deltaY);
//}
