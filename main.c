#pragma config(Sensor, S4,     LightSensor,         sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//********************************************************
//********************************************************
//*!!Sensor, S1, SonarSensor, !!*//
//*!!Sensor, S4, LightSensor, sensorLightActive, , !!*//
//*!!Motor, motorA, motorA, tmotorNxtEncoderClosedLoop, !!*//
//*!!Motor, motorB, motorB, tmotorNxtEncoderClosedLoop, !!*//
//*!! !!*//
//*!!Start automatically generated configuration code. !!*//
const tSensors SonarSensor = (tSensors) S1; //*!!!!*//
//const tSensors LightSensor = (tSensors) S4; //sensorLightActive //*!!!!*//
const tMotor motorA = (tMotor) motorA; //tmotorNxtEncoderClosedLoop //*!!!!*//
const tMotor motorB = (tMotor) motorB; //tmotorNxtEncoderClosedLoop //*!!!!*//
//*!!CLICK to edit 'wizard' created sensor & motor configuration. !!*//

/**********************************************************************************
* File:         main.c
* Authors:      Greg Nehus, Matt Odille
* Description:  This program is written in ROBOTC for the Lego Mindstorms NXT
*               platform.  It's a $$$$$$$ make bank
*
* motorA: Drive
* motorB: Steer
* S1: Sonar
* S4: Light
*
*********************************************************************************/

/**********************************************************************************
* Preprocessor Definitions
*********************************************************************************/
#define TARGET_LIGHT_VALUE 30
#define MOTOR_A_SPEED -15
#define MOTOR_B_SPEED 75

/**********************************************************************************
* Function prototypes
*********************************************************************************/
void set_steering_angle(int angle);
void halt();

/**********************************************************************************
* Global variables for steering motor
*********************************************************************************/
int steeringAngle = 45; //this assumes initial steering angle is straight

/**********************************************************************************
* Global variables for PID controller
*********************************************************************************/
float dState[2];  //Last position input
float iState[2];  //Integrator state
float iMax[2];    //Maximum allowable integrator state
float iMin[2];    //Minimum allowable integrator state
float pGain[2];   //Proportional gain
float iGain[2];   //Integral gain
float dGain[2];   //Derivative gain

/**********************************************************************************
* LightSensor
*********************************************************************************/
int nLight;
float fError = 0.0;
float fsError = 0.0;

/**********************************************************************************
* Task (thread) for reading from the LightSensor
*********************************************************************************/
task tLightSensor()
{
	nSchedulePriority = kDefaultTaskPriority;
	SensorMode[LightSensor] = modePercentage;
	while(true)
	{
	  // delay 3 milliseconds since that's the fastest the sensor can read
		wait1Msec(3);

		// take a reading and calculate the error
		nLight = SensorValue(LightSensor);
		nxtDisplayCenteredBigTextLine(2, "S4=%d", nLight);
		fError = (TARGET_LIGHT_VALUE - nLight);
		if (fError > fsError) fsError = fError;
	}
	return;
}


/**********************************************************************************
* PID controller
*********************************************************************************/
float UpdatePID(int x, float error, float position)
{
	float pTerm = 0.0, dTerm = 0.0, iTerm = 0.0, result = 0.0;
	pTerm = pGain[x] * error;
	// calculate the proportional term
	// calculate the integral state with appropriate limiting
	iState[x] += error;
	if (iState[x] > iMax[x])
	  iState[x] = iMax[x];
	else
	  if (iState[x] < iMin[x])
	    iState[x] = iMin[x];
	iTerm = iGain[x] * iState[x]; // calculate the integral term
	dTerm = dGain[x] * (position - dState[x]);
	dState[x] = position;
	result = pTerm + iTerm - dTerm;
	return (result);
}

/**********************************************************************************
* Arbiter nAngle is the PID command
*********************************************************************************/
void Arbiter(int nAngle)
{
	int outputAngle = 0;

	// Initialize the motors
	bFloatDuringInactiveMotorPWM = false;
	//nMaxRegulatedSpeedNxt = 2160;
	//nPidUpdateInterval = 1;
	//nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	//nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	motor[motorA] = MOTOR_A_SPEED;
	set_steering_angle(nAngle);

	// PID save area.
	dState[0] = 0.0;
	iState[0] = 0.0;

	// Tune the PID using gains parameters
	pGain[0] = 2.95;
	iGain[0] = 0.0;
	dGain[0] = 0.026;

	// Percent of the input command (steering angle)
	iMin[0] = (nAngle / 100.0) * 25.0;
	iMax[0] = (nAngle / 100.0) * 75.0;

	while (true)
	{
		// call the PID controller
		if (fError != 0.0)
		{
			outputAngle = nAngle - (int) UpdatePID(0,abs(fError),abs(fError));
			if (outputAngle > nAngle) outputAngle = nAngle;
			if (outputAngle < 0) outputAngle = 0;
			if (outputAngle > 90) outputAngle = 90;
			set_steering_angle(outputAngle);
			wait1Msec(1.0);
		}
	}
	motor[motorA] = 0;
	motor[motorB] = 0;
	while(nMotorRunState[motorA] != runStateIdle);
	return;
}

/********************************************************************************
 * Function: void halt()
 * Parameters: None
 * Return: None
 * Description: This function stops the driving motor.
 */
void halt()
{
    motor[motorA] = 0;
    wait1Msec(100);
    return;
}

/********************************************************************************
 * Function: void set_steering_angle()
 * Parameters: the angle, between 0 (left-most) and 90 (right-most)
 * Return: None
 * Description: This function sets the angle of steering.
 */
void set_steering_angle(int angle)
{
  int direction = 1;

  nxtDisplayCenteredBigTextLine(4, "angle=%d", angle);

  // base case
  if(angle == steeringAngle) return;

  // reverse direction if need be
  if(angle < steeringAngle) direction = -1;

	// reset motor encoder value and set motor speeds
	nMotorEncoder[motorB] = 0;
	motor[motorB] = MOTOR_B_SPEED * direction;

	// wait for desired motor encoder value
	while( abs(nMotorEncoder[motorB]) != abs(angle-steeringAngle) );

	// stop motor and return
	motor[motorB] = 0;
	steeringAngle = angle;
	return;
}

//* ********************************************************** *
//* * Main program
//* ********************************************************** *
task main()
{
	nSchedulePriority = kDefaultTaskPriority;
	eraseDisplay();

	// Start Light sensors
	StartTask(tLightSensor);
	wait1Msec(1000);

	// Call the Arbiter
	Arbiter(45);

	StopAllTasks();
	return;
}
