#pragma config(Sensor, S1,     sonarSensor,         sensorSONAR)
#pragma config(Sensor, S4,     lightSensor,         sensorLightActive)
#pragma config(Motor,  motorA,          driveMotor,    tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          steerMotor,    tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************************************************
* Tweakable macros
**********************************************************************************/
// light sensor
#define LIGHT_VALUE_CARPET 30
#define LIGHT_VALUE_TAPE 60

// sonar sensor
#define SONAR_THRESHOLD 200

// steer motor
#define STEER_VALUE_LEFTMOST 0
#define STEER_VALUE_RIGHTMOST 90
#define STEER_SPEED 75

// drive motor
#define DRIVE_SPEED 100

// PID
#define PID_dT 0.015
#define PID_Pc 3

#define PID_Kp 0.5
//#define PID_Ki (2 * PID_Kp * PID_dT / PID_Pc)
#define PID_Ki 0.0
//#define PID_Kd (PID_Kp * PID_Pc / (8 * PID_dT))
#define PID_Kd 0.0026

#define PID_INTEGRAL_MAX 999999
#define PID_INTEGRAL_MIN -999999

//Car info
#define track 4.625
#define wheelbase 7.25

#define WHEEL_DIAMETER 5.5
#define turning_radius 13.6
//#define turning_radius 14.56
/**********************************************************************************
* Global variables
**********************************************************************************/
// PID
float Kp = PID_Kp;     //the Konstant for the proportional controller
float Tp;     //the Target steering angle (straight)
float offset; //average of the tape and carpet readings
float Ki = PID_Ki;
float integral = 0.0;
float Kd = PID_Kd;
float prevError = 0.0;

// Light sensor
float error = 0.0;

// Steer motor
int steeringAngle = 45;//(STEER_VALUE_LEFTMOST + STEER_VALUE_RIGHTMOST) / 2; //this requires initial steering angle to be straigh ahead

// Park
bool isParking = false;


/**********************************************************************************
* Function prototypes
**********************************************************************************/
float GetPID(float fError);
void SetSteeringAngle(int targetAngle);
void park(float deltaX, float deltaY);

float inches_to_centimeters(float inches);
void drive(float distance);
float get_angle_between_circles(float deltaX, float deltaY);
float get_distance(float deltaX, float deltaY);
float get_needed_park_y_coordinate(float deltaX);

/**********************************************************************************
* Light sensor thread
**********************************************************************************/
task tLightSensor()
{
	nSchedulePriority = kDefaultTaskPriority;
	SensorMode[lightSensor] = modePercentage;
	int LightValue;

	while(!isParking)
	{
	  // delay 3 milliseconds since that's about the fastest the light sensor can read
		wait1Msec(3);
		wait1MSec(100);

		// take a sensor reading and calculate the error by subtracting the offset
		LightValue = SensorValue(lightSensor);
		error = LightValue - offset;
		//nxtDisplayTextLine(1, "S4=%d", LightValue);
		//nxtDisplayTextLine(3, "error=%d", error);
	}
	return;
}

/**********************************************************************************
* Sonar sensor thread
**********************************************************************************/
task tSonarSensor()
{
	nSchedulePriority = kDefaultTaskPriority;
	int SonarValue;

	while(!isParking)
	{
	  // delay 15 milliseconds since that's about the fastest the sonar sensor can read
		wait1Msec(15);

		// take a sensor reading
		SonarValue = SensorValue(sonarSensor);
		nxtDisplayCenteredBigTextLine(3, "S1=%d", SonarValue);

		// TODO: if(adequate parking space is found), then set isParking flag to true (kills line-following)
	}

	return;
}

/**********************************************************************************
* Main thread
**********************************************************************************/
task main()
{
  int controllerOutput;

	nSchedulePriority = kDefaultTaskPriority;
	bFloatDuringInactiveMotorPWM = false;
	eraseDisplay();

	// initialize values of PID globals
	offset = (LIGHT_VALUE_CARPET + LIGHT_VALUE_TAPE) / 2;
	Tp = (STEER_VALUE_LEFTMOST + STEER_VALUE_RIGHTMOST) / 2;
	//Kp = 0.5;//(STEER_VALUE_LEFTMOST - STEER_VALUE_RIGHTMOST) / (LIGHT_VALUE_CARPET - LIGHT_VALUE_TAPE);
	integral = 0;

	//park(5,0);
	//while(1);
	// start sonar sensor
	StartTask(tSonarSensor);
	wait1Msec(1000);

	// start light sensor
	StartTask(tLightSensor);
	wait1Msec(1000);

	// drive
	motor[driveMotor] = DRIVE_SPEED;

	// perform line-following
	while(!isParking)
	{
	  controllerOutput = GetPID(error);
	  //nxtDisplayTextLine(5, "PID=%d", controllerOutput);
	  SetSteeringAngle(Tp + controllerOutput);
	}

	// perform parallel parking
	//Park();

}











/**********************************************************************************
* Function: float GetPID()
* Parameters: takes the current error reading as its only argument
* Return: None
* Description: This method returns the PID output (a steering angle adjustment)
**********************************************************************************/
float GetPID(float fError)
{
  float pTerm = 0.0, dTerm = 0.0, iTerm = 0.0;

  // [p]roportional term calculations
  pTerm = Kp * fError;

  // [i]ntegral term calculations
  integral = integral + fError;
	if (integral > PID_INTEGRAL_MAX)
	  integral = PID_INTEGRAL_MAX;
	else
	  if (integral < PID_INTEGRAL_MIN)
	    integral = PID_INTEGRAL_MIN;
  iTerm = Ki * integral;

  // [d]erivative term calculations
  dTerm = Kd * (fError - prevError);
  prevError = fError;

	return (pTerm + iTerm + dTerm);
}

/**********************************************************************************
* Function: void Park()
* Parameters: None
* Return: None
* Description: This function performs parallel parking.
**********************************************************************************/


/**********************************************************************************
* Function: void SetSteeringAngle()
* Parameters: the target angle, between 0 (left-most) and 90 (right-most)
* Return: None
* Description: This function sets the angle of steering.
**********************************************************************************/
void SetSteeringAngle(int targetAngle)
{
  int targetMotorEncoderValue;
  int direction;
  //nxtDisplayTextLine(7, "steer=%d", targetAngle);

  // error-handling
  if(targetAngle < STEER_VALUE_LEFTMOST) targetAngle = STEER_VALUE_LEFTMOST;
  if(targetAngle > STEER_VALUE_RIGHTMOST) targetAngle = STEER_VALUE_RIGHTMOST;

  // base case
  if(targetAngle == steeringAngle) return;

  if(targetAngle < steeringAngle)
  {
    // left turn case
    direction = -1;
    targetMotorEncoderValue = steeringAngle - targetAngle;
    if(isParking) targetMotorEncoderValue = targetMotorEncoderValue + 6;
  }
  else
  {
    // right turn case
    direction = 1;
    targetMotorEncoderValue = targetAngle - steeringAngle ;
  }

	// reset motor encoder value and set motor speeds
	nMotorEncoder[steerMotor] = 0;
	motor[steerMotor] = STEER_SPEED * direction;

	// wait for desired motor encoder value
	while( abs(nMotorEncoder[steerMotor]) <= (int)(targetMotorEncoderValue ) );

	// stop motor and return
	steeringAngle = targetAngle;
	motor[steerMotor] = 0;
	//wait1Msec(10);
	return;
}

void park(float deltaX, float deltaY){
   float currentTurningCircleOrigin_X,currentTurningCircleOrigin_Y;
   float parkedTurningCircleOrigin_X, parkedTurningCircleOrigin_Y;

   deltaX = deltaX + track/2.0 ;
   currentTurningCircleOrigin_X = turning_radius - track/2;
   currentTurningCircleOrigin_Y = 0;

   parkedTurningCircleOrigin_X = deltaX - turning_radius + track/2;
   currentTurningCircleOrigin_Y = deltaY;

   float circleDeltaX = parkedTurningCircleOrigin_X - currentTurningCircleOrigin_X;
   float nX = get_needed_park_y_coordinate(circleDeltaX);
   //double nCarx = nX

   //while(1);
   drive(inches_to_centimeters(nX - deltaY));
  int x;




   /*
   SetSteeringAngle(0);
   while(1){
     SetSteeringAngle(45);
     wait10Msec(100);
     SetSteeringAngle(-45);
     wait10Msec(100);
     SetSteeringAngle(0);
     wait10Msec(100);

   }
   */
   SetSteeringAngle(90);

   //float turningRadius = getTurningRadius();
   //nxtDisplayCenteredTextLine(4, "radius=%d", turningRadius);
   //while(1);
   //drive(inches_to_centimeters(turning_radius * PI * 2));

   //while(1);
   float angleBetweenCircle = get_angle_between_circles(circleDeltaX,deltaY + nX);

   nxtDisplayCenteredTextLine(4, "angle= %f", angleBetweenCircle);
   drive(inches_to_centimeters(turning_radius * angleBetweenCircle));

   SetSteeringAngle(0);
   drive( inches_to_centimeters( turning_radius * (angleBetweenCircle) )+  wheelbase);
   //drive(- turning_radius * get_angle_between_circles(deltaX, deltaY));
  StartTask(we_are_the_champions);
}

float get_angle_between_circles(float deltaX, float deltaY){

    return atan(deltaY/deltaX);
}


void drive(float distance){

  nMotorEncoder[motorA] = 0;
  motor[motorA] =  (abs((int)distance)/(int)distance) * DRIVE_SPEED;

  while (abs(nMotorEncoder[motorA]) < (long)abs(distance / (PI * WHEEL_DIAMETER) * 360.00));
  motor[motorA] = 0;



}
float get_distance(float deltaX, float deltaY){
    return sqrt( deltaX * deltaX + deltaY * deltaY);
}

float get_needed_park_y_coordinate(float deltaX){
  float distance = ((turning_radius * 2) - track) * ((turning_radius * 2) - track);
   return sqrt( distance   - (deltaX * deltaX));
}

float inches_to_centimeters(float inches){
  return inches * 2.54;
}
